Relatório sobre Samples de Agentes do Google ADK
1. Introdução e Escopo do Relatório
Este relatório tem como objetivo fornecer uma análise detalhada dos projetos de exemplo (samples) de agentes implementados com o Google Agent Development Kit (ADK), disponíveis no repositório google/adk-samples/tree/main/python/agents. Para cada agente, exploraremos seu tipo de projeto, composição interna, modo de operação, sincronização, função do agente principal e a integração de ferramentas ou delegação a subagentes. O objetivo é oferecer uma compreensão clara da arquitetura e das capacidades de cada exemplo, útil para desenvolvedores com experiência em ADK.

2. Conceitos Fundamentais e Terminologia do ADK
Para uma compreensão aprofundada dos agentes e seus funcionamentos, é essencial definir os seguintes termos técnicos no contexto do Google ADK:

Agente Único (Single-Agent): Um projeto de agente único é aquele em que uma única instância de agente é responsável por todas as tarefas e interações, sem delegar a outros agentes especializados.
Multi-Agente (Multi-Agent): Um sistema multi-agente é uma aplicação composta por múltiplas instâncias de agentes distintos que colaboram ou coordenam para alcançar um objetivo maior. Esses agentes geralmente formam uma hierarquia e podem ter papéis especializados, permitindo modularidade e escalabilidade em tarefas complexas.Cite: src-1
Composição Interna: Refere-se aos principais componentes de um projeto de agente ADK, como arquivos de código (agent.py, módulos auxiliares), suas dependências externas (bibliotecas, APIs) e o fluxo lógico de como esses componentes interagem durante a execução.
Modo de Operação: Descreve como o agente gerencia a execução de tarefas. Pode ser um "loop contínuo" (o agente espera por entradas, processa e repete o ciclo indefinidamente, comum em chatbots e assistentes) ou "execução paralela" (múltiplas tarefas ou componentes do agente podem ser executados simultaneamente ou concorrentemente para aumentar a eficiência).Cite: src-1, src-2, src-3
Sincronização: Refere-se à maneira como as operações são coordenadas no tempo.
Execução Síncrona (Synchronous): As tarefas são executadas sequencialmente, uma após a outra. Cada tarefa deve ser concluída antes que a próxima possa começar. Isso pode bloquear o fluxo de execução enquanto uma operação está em andamento.Cite: src-3, src-4, src-5
Execução Assíncrona (Asynchronous): Permite que múltiplas tarefas sejam executadas concomitantemente sem bloquear o fluxo principal. Isso é particularmente útil para operações de E/S (entrada/saída), como chamadas de API ou acesso a bancos de dados, onde a aplicação pode continuar processando outras tarefas enquanto espera por uma resposta.Cite: src-3, src-4, src-5, src-6
Ferramentas (Tools): Em ADK, uma ferramenta é um wrapper em torno de uma função ou capacidade que o agente pode chamar para realizar ações no mundo real. Elas são como as "mãos" do agente, permitindo que ele execute tarefas como recuperar informações, processar dados, enviar mensagens ou até mesmo invocar outro agente.Cite: src-7, src-8, src-9
Subagentes (Sub-Agents): Agentes especializados que operam sob a orquestração de um agente principal (pai) ou de um Workflow Agent. Eles recebem tarefas delegadas e contribuem para o objetivo geral do sistema multi-agente, promovendo a modularidade.Cite: src-1, src-10, src-11
Orquestrador (Orchestrator): Um agente central ou componente que coordena a interação entre múltiplos agentes, atribuindo tarefas, gerenciando a comunicação e mantendo o contexto do sistema para garantir que o objetivo geral seja alcançado.Cite: src-1, src-10, src-12, src-13
Model Context Protocol (MCP): Um protocolo que permite estender as capacidades dos agentes, equipando-os com ferramentas personalizadas e contexto, permitindo que acessem informações específicas ou realizem tarefas especializadas, muitas vezes interagindo com APIs externas.Cite: src-12, src-14, src-15, src-16
Agent-to-Agent (A2A) Protocol: Um protocolo que facilita a comunicação e coordenação direta entre agentes, geralmente via APIs REST, permitindo que agentes independentes colaborem em um fluxo de trabalho.Cite: src-13, src-15
3. Visão Geral dos Agentes de Exemplo do Google ADK (Python)
A seguir, uma lista dos agentes de exemplo encontrados no diretório google/adk-samples/tree/main/python/agents:Cite: src-17

academic-research
brand-search-optimization
customer-service
data-science
financial-advisor
fomc-research
gemini-fullstack
image-scoring
llm-auditor
marketing-agency
personalized-shopping
RAG
software-bug-assistant
travel-concierge
Além dos listados explicitamente, o conceito de um simple-tool-agent é fundamental para o ADK, representando um agente único básico que utiliza ferramentas, e será abordado em uma seção dedicada.

4. Análise Detalhada dos Agentes de Exemplo
4.1. academic-research
Tipo de projeto: Multi-agent.Cite: src-12, src-18
Composição interna: Estrutura-se com um agente orquestrador que delega a subagentes especializados em diferentes aspectos do processo de pesquisa. Exemplos de componentes de subagentes, inspirados no contexto de pesquisa de software (FixAgent), podem incluir Helper (pesquisa online), RepoFocus (análise de dependências de código), Summarizer, Slicer (isola segmentos de código), Locator (identifica linhas de erro), Fixer (gera patches) e FixerPro (gera patches otimizados). Dependências típicas incluem APIs e bancos de dados para buscar e analisar informações.Cite: src-12, src-18
Modo de operação: Opera em um fluxo de trabalho iterativo e adaptativo, com delegação de tarefas. O processo pode envolver um fluxo de três níveis de profundidade (como visto no FixAgent) que se adapta à complexidade da pesquisa ou do problema, permitindo um fluxo de execução condicional e iterativo.Cite: src-18
Sincronização: A coordenação hierárquica e a delegação entre subagentes sugerem uma combinação de execução síncrona (para etapas interdependentes, garantindo a ordem lógica) e assíncrona (para chamadas de API externas ou sub-tarefas de pesquisa que podem ser executadas em paralelo para eficiência). O Runner do ADK opera assincronamente.Cite: src-1
Função do agente principal: O agente principal (orquestrador) coordena o processo de pesquisa, atribuindo tarefas a subagentes. Sua responsabilidade é planejar e supervisionar a coleta, análise e síntese de informações. No contexto de depuração (FixAgent), o orquestrador decide quais subagentes ativar e em qual nível de profundidade para resolver o problema.Cite: src-18
Integração de ferramentas: O agente de pesquisa se integra a ferramentas externas e APIs para realizar suas funções. Por exemplo, o Helper pode invocar um motor de busca externo para recuperar soluções. Slicer, Locator e Fixer podem invocar ferramentas tradicionais de análise de código. Isso demonstra um forte uso de ferramentas para estender suas capacidades além da geração de linguagem natural.Cite: src-18
4.2. brand-search-optimization
Tipo de projeto: Provavelmente Multi-agent. A otimização de busca de marca é uma tarefa complexa que pode se beneficiar da especialização de múltiplos agentes, dado o foco do ADK em sistemas multi-agentes.Cite: src-8, src-13, src-19
Composição interna: Agentes de otimização de busca para marcas precisariam de componentes para análise de dados de SEO, pesquisa de palavras-chave, análise competitiva, monitoramento de desempenho e, possivelmente, integração com plataformas de publicidade digital. As dependências incluiriam acesso a APIs de motores de busca, ferramentas de análise de SEO (como Georanker para relatórios de ranking local e AdStage para gerenciamento de campanhas digitais) e Large Language Models (LLMs) para processamento e geração de linguagem natural.Cite: src-20, src-21
Modo de operação: Pode operar em um loop contínuo de monitoramento e otimização, onde o agente analisa o desempenho, identifica oportunidades de melhoria e executa ações de forma iterativa. A orquestração de tarefas complexas de marketing digital e otimização sugere a capacidade de executar tarefas em paralelo (e.g., monitorar várias campanhas ou palavras-chave simultaneamente).Cite: src-20
Sincronização: Dada a natureza de monitoramento contínuo e a necessidade de interagir com APIs externas (que são tipicamente de E/S intensiva), a execução provavelmente seria assíncrona para manter a responsividade e eficiência do sistema.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal seria responsável por orquestrar a estratégia de otimização de busca de uma marca. Isso inclui analisar o desempenho de SEO, identificar áreas de melhoria, planejar campanhas e possivelmente executar ajustes, visando aumentar a visibilidade da marca e o ranking nos resultados de busca.Cite: src-20, src-21
Integração de ferramentas: Forte integração com ferramentas e plataformas de SEO e marketing digital, como Georanker e AdStage. O agente utilizaria essas ferramentas para coletar dados, analisar métricas (CTR, taxa de conversão, CPA) e otimizar campanhas. A delegação ocorre através dessas ferramentas para a execução de tarefas específicas de análise e ajuste.Cite: src-21
4.3. customer-service
Tipo de projeto: Provavelmente Multi-agent. Agentes de atendimento ao cliente frequentemente precisam lidar com uma variedade de intenções do usuário e escalar para diferentes especialistas, o que se alinha com uma arquitetura multi-agente.Cite: src-10, src-22
Composição interna: Um agente de serviço ao cliente com ADK provavelmente conteria um agente de triagem (classificador), agentes especializados para diferentes tópicos de suporte (e.g., faturamento, suporte técnico, informações de produto), e possivelmente um agente para escalar para um agente humano. Componentes incluiriam módulos para processamento de linguagem natural, gerenciamento de conhecimento (para FAQs, documentação) e integração com sistemas CRM ou bases de dados de clientes.
Modo de operação: Um loop contínuo de interação com o usuário, onde o agente recebe uma consulta, a processa e responde ou delega. A delegação a subagentes ou a um agente humano sugere um fluxo de execução adaptativo e condicional.Cite: src-10
Sincronização: As interações em um sistema de atendimento ao cliente precisam ser altamente responsivas, o que aponta para um design assíncrono para lidar com múltiplas interações de usuários e chamadas de ferramentas/APIs simultaneamente, evitando bloqueios na interface do usuário.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal seria um Orquestrador ou "Dispatcher" que recebe as consultas iniciais do cliente, as classifica e as roteia para o subagente especializado mais apropriado ou para um agente humano, se necessário.Cite: src-10
Integração de ferramentas: O agente faria uso extensivo de ferramentas para pesquisa em bases de conhecimento (FAQs, documentação), acesso a informações do cliente em sistemas CRM, execução de ações como atualização de status de pedidos ou início de reembolsos, e possivelmente ferramentas para escalonamento de tickets ou comunicação com agentes humanos.Cite: src-10, src-22
4.4. data-science
Tipo de projeto: Multi-agent.Cite: src-23
Composição interna: Este projeto demonstra um sistema multi-agente projetado para tarefas de análise de dados. Ele integra vários agentes especializados para lidar com diferentes aspectos do pipeline de dados, desde a recuperação de dados até análises avançadas e aprendizado de máquina. Utiliza o BigQuery para interação e pode realizar manipulações complexas de dados e criar visualizações. Inclui ferramentas como "DB agents" (para recuperação de dados de banco de dados, convertendo linguagem natural em SQL) e "DS agents" (para análise e apresentação de dados usando Fast API). Mantém o estado da sessão para que as ferramentas tenham conhecimento do contexto.Cite: src-23
Modo de operação: O agente principal atua como um "multi-agent orchestration tool" ou "orchestration agent" que coordena e toma decisões, delegando tarefas a agentes especializados com base na solicitação. Isso implica um fluxo de execução controlado e adaptativo, potencialmente com execuções paralelas de sub-tarefas.Cite: src-23
Sincronização: A delegação de tarefas a subagentes e a manutenção do estado da sessão entre ferramentas sugerem que o sistema pode operar tanto de forma síncrona (para etapas sequenciais do pipeline de dados) quanto assíncrona (para processamento de dados ou chamadas de API que podem ser demoradas), com o Runner do ADK operando assincronamente para eficiência.Cite: src-6, src-11, src-23
Função do agente principal: O agente principal atua como o Orquestrador, coordenando as ações e delegando tarefas a subagentes especializados para recuperação, análise e visualização de dados. Ele é responsável pela tomada de decisões centralizada no fluxo de trabalho de ciência de dados.Cite: src-23
Integração de ferramentas: Integra ferramentas específicas para ciência de dados: "DB agents" (ferramenta para chamar bancos de dados e processar linguagem natural em consultas SQL) e "DS agents" (ferramenta para análise e apresentação de dados via Fast API). A delegação ocorre através dessas ferramentas, que podem ser consideradas subagentes ou funcionalidades de ferramentas complexas.Cite: src-23
4.5. financial-advisor
Tipo de projeto: Provavelmente Multi-agent. Aconselhamento financeiro envolve diversas áreas (investimento, planejamento, impostos) que se beneficiariam de agentes especializados em cada domínio, o que é um caso de uso forte para ADK multi-agente.Cite: src-13, src-19
Composição interna: Envolveria um agente principal orquestrador e subagentes especializados em, por exemplo, análise de mercado, planejamento de investimentos, planejamento de aposentadoria ou análise de risco. As dependências incluiriam acesso a dados financeiros (preços de ações, relatórios econômicos), APIs de notícias financeiras, e módulos para modelagem e análise preditiva.Cite: src-9
Modo de operação: Pode operar em um loop de consulta-resposta, mas também em um modo proativo de monitoramento do mercado financeiro. A orquestração de análises financeiras complexas pode envolver execução paralela de subagentes para diferentes tipos de análises e relatórios.
Sincronização: A necessidade de processar grandes volumes de dados financeiros e realizar análises complexas em tempo hábil sugere um modelo de execução predominantemente assíncrona, especialmente para chamadas de API e cálculos intensivos, para garantir a responsividade do conselheiro.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal atuaria como o "Financial Advisor" central, que recebe as consultas do usuário e as delega aos subagentes especializados para obter informações detalhadas, realizar análises e gerar recomendações personalizadas com base nos objetivos do usuário.
Integração de ferramentas: Utilizaria ferramentas para acessar dados de mercado em tempo real, realizar cálculos financeiros complexos, gerar relatórios e gráficos, integrar-se com plataformas de negociação ou gestão de portfólio, e acesso a bancos de dados de notícias e regulamentações financeiras.Cite: src-9
4.6. fomc-research
Tipo de projeto: Provavelmente Multi-agent. Pesquisas sobre o FOMC (Federal Open Market Committee) envolvem análise de documentos complexos, dados econômicos e históricos, o que se presta a uma abordagem multi-agente com especialização em RAG (Retrieval Augmented Generation) e análise de texto.
Composição interna: O agente pode ter um orquestrador e subagentes focados em recuperação de documentos (atas, declarações, transcrições de reuniões), análise de sentimentos em declarações, extração de dados econômicos relevantes e síntese de relatórios. Dependências incluiriam APIs para acesso a repositórios de documentos, bases de dados econômicas e LLMs para RAG e sumarização.
Modo de operação: O processo de pesquisa seria iterativo, onde o agente busca informações, as processa, reflete sobre as lacunas de conhecimento e refina a busca. Pode envolver um fluxo sequencial para a análise de documentos e paralelo para a recuperação de múltiplas fontes simultaneamente.
Sincronização: A natureza da pesquisa e recuperação de documentos, que pode ser intensiva em E/S, sugere uma arquitetura assíncrona para garantir a eficiência e a capacidade de resposta ao lidar com grandes volumes de dados.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal atuaria como o "FOMC Research Assistant", responsável por entender a consulta do usuário, planejar a estratégia de pesquisa, delegar tarefas aos subagentes (como recuperação de documentos e análise de dados), e sintetizar as descobertas em um relatório coerente e fundamentado.
Integração de ferramentas: Faria uso intensivo de ferramentas para busca e recuperação de documentos (RAG), análise de texto e extração de entidades, visualização de dados econômicos e, possivelmente, ferramentas de sumarização e geração de relatórios para apresentar os insights da pesquisa.
4.7. gemini-fullstack
Tipo de projeto: Multi-agent.Cite: src-24
Composição interna: É uma aplicação fullstack com um frontend React e um backend impulsionado por LangGraph. O backend contém a lógica do agente de pesquisa e usa modelos Gemini. A arquitetura de backend, definida em app/agent.py, utiliza uma equipe de agentes especializados (e.g., recipe_generator, pediatrician_critic_agent, recipe_refiner_agent) que colaboram. Para produção, requer uma instância Redis (para streaming de saída em tempo real) e um banco de dados Postgres (para persistência de estado do thread e memória de longo prazo).Cite: src-24, src-25
Modo de operação: O agente opera em um loop contínuo de "Refinamento Iterativo". Ele gera consultas iniciais, realiza pesquisa web, reflete sobre os resultados para identificar lacunas de conhecimento, e, se necessário, gera consultas de acompanhamento, repetindo as etapas de pesquisa web e reflexão até atingir uma resposta bem fundamentada com citações.Cite: src-25
Sincronização: A natureza iterativa e o uso de LangGraph (que lida com gráficos de computação) e Redis (para streaming de saída em tempo real) sugerem um design predominantemente assíncrono para permitir que as operações de pesquisa e reflexão ocorram sem bloquear o processo principal, otimizando o desempenho.Cite: src-25
Função do agente principal: O agente principal, neste contexto, é o orquestrador impulsionado por LangGraph. Sua função é conduzir uma pesquisa abrangente, gerando termos de busca, consultando a web, refletindo sobre os resultados para identificar lacunas e refinando iterativamente sua busca até fornecer uma resposta bem fundamentada com citações. No exemplo "Tiny Tastes", coordena a geração, crítica e refinamento de receitas.Cite: src-24, src-25
Integração de ferramentas: Integra fortemente a API do Google Search para pesquisa web. As tarefas são decompostas em subagentes especializados, o que pode ser visto como uma forma de delegação interna através de "agente-como-ferramenta" (Agent-as-a-Tool), onde um agente invoca outro como uma ferramenta. O modelo Gemini é usado para tomada de decisões e geração de texto, atuando como o "cérebro" para reflexão e geração de consultas.Cite: src-7, src-24, src-25
4.8. image-scoring
Tipo de projeto: Pode ser Single-agent ou Multi-agent, dependendo da complexidade do processo de pontuação e dos critérios envolvidos. Para análises mais complexas ou multiperspectivas, uma arquitetura multi-agente seria mais robusta.
Composição interna: Um agente de pontuação de imagem poderia ter componentes para entrada de imagem, pré-processamento (redimensionamento, normalização), análise de recursos (usando modelos de visão computacional ou LLMs multimodais como Gemini), e aplicação de lógica de pontuação baseada em critérios definidos. As dependências incluiriam bibliotecas de processamento de imagem, modelos de Machine Learning (ML) para visão computacional e, possivelmente, APIs externas para enriquecimento de dados de imagem ou acesso a bancos de dados de metadados.
Modo de operação: O modo de operação seria tipicamente um processamento sob demanda (baseado em requisição) ou um loop contínuo se estivesse monitorando uma fila de imagens para processamento em lote. O processamento de uma imagem individual seguiria um fluxo sequencial (pré-processamento → análise → pontuação).
Sincronização: Dada a natureza computacionalmente intensiva do processamento de imagens e o uso potencial de modelos de ML, as operações provavelmente seriam executadas de forma assíncrona para lidar com múltiplas solicitações eficientemente sem bloquear o sistema.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal receberia uma imagem e critérios de pontuação, orquestraria o processo de análise (se multi-agente, delegando a subagentes especializados) e retornaria uma pontuação ou um relatório detalhado sobre a imagem, com base nos critérios estabelecidos.
Integração de ferramentas: Utilizaria ferramentas para processamento de imagem (manipulação de pixels, detecção de objetos, extração de características), chamadas a modelos de visão computacional (e.g., modelos no Vertex AI) e, se aplicável a LLMs multimodais, para geração de descrições textuais da imagem.
4.9. llm-auditor
Tipo de projeto: Provavelmente Multi-agent. A auditoria de LLMs pode envolver múltiplos critérios (viés, segurança, precisão, coerência, conformidade), cada um potencialmente avaliado por um subagente especializado, tornando a arquitetura multi-agente a mais adequada.
Composição interna: Um agente de auditoria de LLMs poderia ter um orquestrador e subagentes especializados em detecção de viés, análise de toxicidade, verificação de fatos, avaliação de coerência e conformidade com políticas de uso. As dependências incluiriam LLMs para geração de texto (para testar o LLM auditado), modelos de classificação para viés/toxicidade, acesso a bancos de dados de conhecimento para verificação de fatos e frameworks de avaliação para comparar saídas.
Modo de operação: Operaria em um loop de avaliação, onde o agente recebe saídas de LLM (ou gera prompts para obtê-las), aplica critérios de auditoria usando os subagentes especializados, gera relatórios e pode sugerir refinamentos no LLM auditado. A avaliação de múltiplos critérios pode ocorrer em paralelo.
Sincronização: As operações de avaliação, especialmente aquelas que envolvem chamadas a modelos e comparações de dados em larga escala, seriam eficientemente realizadas de forma assíncrona para permitir o processamento de múltiplas auditorias ou fluxos de avaliação.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal atuaria como o "LLM Auditor", responsável por receber prompts e respostas de um LLM, e orquestrar os subagentes para realizar uma auditoria abrangente, identificando potenciais problemas (como viés ou imprecisão) e gerando um relatório de auditoria detalhado.
Integração de ferramentas: Utilizaria ferramentas para análise de texto (para detectar viés, toxicidade, etc.), comparação de texto com fontes de verdade, e geração de relatórios de auditoria. Também poderia integrar ferramentas para interagir diretamente com o LLM sob auditoria (enviar prompts e receber respostas programaticamente).
4.10. marketing-agency
Tipo de projeto: Multi-agent. Uma agência de marketing envolve várias funções (estratégia, criação de conteúdo, publicidade, análise, relações com o cliente), tornando-o um caso de uso ideal para uma arquitetura multi-agente, onde cada agente é especializado em uma dessas funções.Cite: src-22
Composição interna: O agente principal seria um "Marketing Strategist" ou Orquestrador, coordenando subagentes como "Content Creator" (para geração de texto, ideias de imagem, vídeos), "Ad Campaign Manager" (para otimização de anúncios e gerenciamento de lances), "Social Media Manager", e "Analytics Reporter". As dependências incluiriam LLMs para geração de conteúdo, APIs de plataformas de publicidade (e.g., Google Ads, Facebook Ads), ferramentas de análise de marketing e bases de dados de clientes para personalização.
Modo de operação: Operaria em um loop contínuo de planejamento, execução, monitoramento e otimização de campanhas de marketing. A natureza das campanhas de marketing permitiria muitas execuções paralelas (e.g., gerenciamento de várias campanhas de anúncios, automação de posts em redes sociais).
Sincronização: Dada a necessidade de gerenciar múltiplas campanhas e interagir com diversas plataformas externas em tempo real, um design assíncrono seria crucial para a escalabilidade e responsividade do sistema, garantindo que as operações não bloqueiem umas às outras.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal ("Marketing Agency Orchestrator") receberia os objetivos de marketing do cliente, formularia uma estratégia abrangente e delegaria a execução e o monitoramento a subagentes especializados, consolidando os resultados e ajustando a estratégia conforme necessário para atingir os KPIs.
Integração de ferramentas: Faria uso extensivo de ferramentas para criação de conteúdo (texto, ideias de imagem), otimização de lances de anúncios e gerenciamento de campanhas, análise de métricas de desempenho de marketing, publicação em plataformas de mídia social e integração com CRMs e ferramentas de e-mail marketing.Cite: src-22
4.11. personalized-shopping
Tipo de projeto: Provavelmente Multi-agent. Compras personalizadas exigem uma compreensão multifacetada do usuário (preferências, histórico, orçamento), busca e comparação de produtos em diversas fontes, e consideração de feedback, um processo complexo que se beneficia da delegação e especialização.
Composição interna: Poderia ter um agente "Personal Shopper" como orquestrador e subagentes como "Product Recommender" (para sugestão de itens), "Price Comparator" (para comparar preços entre varejistas), "Style Advisor" (para conselhos de moda/estilo), e "Customer Preferences Agent" (para manter e usar o perfil do usuário). As dependências incluiriam acesso a catálogos de produtos de e-commerce, APIs de diversas lojas online, modelos de recomendação e módulos para processamento de linguagem natural para entender as preferências do usuário.
Modo de operação: Operaria em um loop de interação com o usuário, refinando recomendações com base no feedback contínuo. A busca e comparação de produtos de diferentes fontes poderiam ser executadas em paralelo para apresentar opções rapidamente.
Sincronização: Para fornecer uma experiência de compra responsiva e em tempo real, as operações seriam predominantemente assíncronas, especialmente ao interagir com múltiplas APIs de e-commerce e processar grandes volumes de dados de produtos.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal atuaria como um "Personal Shopper", entendendo as necessidades e preferências do usuário, buscando e filtrando produtos de acordo com critérios específicos, fornecendo recomendações e, possivelmente, auxiliando no processo de compra, desde a seleção até a finalização.
Integração de ferramentas: Utilizaria ferramentas para busca em catálogos de produtos de e-commerce, comparação de preços e recursos entre produtos, filtragem de produtos com base em preferências e histórico do usuário, e integração com sistemas de revisão de produtos ou dados de inventário para informações atualizadas.
4.12. RAG
Tipo de projeto: Pode ser Single-agent (um LLMAgent que utiliza RAG como uma ferramenta complexa) ou Multi-agent (um orquestrador delegando a subagentes específicos para recuperação e geração, ou um Workflow Agent que coordena o fluxo de RAG). Dado que RAG é uma técnica, o agente é uma implementação que a utiliza.
Composição interna: Um agente RAG típico incluiria um módulo de recuperação (para buscar documentos relevantes de uma base de conhecimento, índice vetorial ou motor de busca), e um módulo de geração (um LLM para sintetizar uma resposta com base nos documentos recuperados e na consulta do usuário). As dependências seriam bancos de dados vetoriais, LLMs (como Gemini), e ferramentas para indexação, busca e recuperação de documentos.
Modo de operação: Operaria em um fluxo de requisição-resposta. A recuperação de documentos e a geração da resposta seriam etapas sequenciais dentro de uma única interação. Pode haver um loop iterativo para refinar a recuperação se a resposta inicial não for satisfatória ou para explorar múltiplas fontes.
Sincronização: As operações de recuperação de documentos e as chamadas de LLM podem ser demoradas, portanto, um design assíncrono seria preferível para garantir que o agente possa lidar com múltiplas consultas simultaneamente sem bloqueio.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal seria responsável por receber a consulta do usuário, acionar o processo RAG para recuperar informações relevantes de fontes externas ou internas e gerar uma resposta informada, contextualizada e citada com base nessas informações.
Integração de ferramentas: A principal "ferramenta" seria o próprio mecanismo RAG, que encapsularia a lógica de busca e recuperação de uma base de conhecimento. Ele pode usar ferramentas para interagir com bancos de dados vetoriais, motores de busca de documentos ou APIs de conhecimento para aumentar a base de informações do LLM.
4.13. simple-tool-agent (Conceitual)
Tipo de projeto: Single-agent. Este tipo de agente representa a arquitetura mais fundamental no ADK, sendo um LLMAgent que utiliza um ou mais Tools sem delegação a subagentes hierárquicos.Cite: src-6, src-7
Composição interna: Um LLMAgent simples usa um Large Language Model (LLM) como seu componente principal para raciocínio, planejamento e tomada de decisões. Ele é configurado com um name, model (e.g., Gemini), uma description, instruction detalhada para o LLM, e um conjunto de tools. Componentes essenciais para gerenciar a execução e o estado da sessão incluem o Runner e o InMemorySessionService.Cite: src-6, src-7
Modo de operação: Opera em um modo de requisição-resposta. Ele recebe uma entrada do usuário, usa o LLM para decidir qual ferramenta chamar (se aplicável, com base na instrução e na descrição das ferramentas), executa a ferramenta e gera uma resposta. A operação é impulsionada pelo LLM usando um "scratchpad" de ações e respostas anteriores para raciocínio iterativo.Cite: src-7
Sincronização: O Runner do ADK opera assincronamente, permitindo que a execução continue sem bloquear enquanto o LLM ou as ferramentas são chamados, o que é crucial para manter a responsividade em interações com o usuário.Cite: src-3, src-4, src-5, src-6
Função do agente principal: A função de um simple-tool-agent seria demonstrar como um único agente pode alavancar um LLM e uma ou mais ferramentas para executar tarefas específicas e delimitadas. Ele é responsável por interpretar a intenção do usuário, selecionar a ferramenta apropriada e usá-la para gerar uma resposta.
Integração de ferramentas: O agente integraria diretamente ferramentas. As ferramentas são definidas como funções Python com metadados (nome, descrição) que o LLM pode usar para decidir quando e como invocá-las de forma autônoma. Não há delegação a subagentes; o LLM dentro do agente principal gerencia diretamente o uso das ferramentas.Cite: src-6, src-7
4.14. software-bug-assistant
Tipo de projeto: Multi-agent, com base na arquitetura hierárquica do FixAgent (um exemplo de agente de depuração de software).Cite: src-18
Composição interna: Conteria um orquestrador e subagentes especializados em diferentes etapas do processo de depuração de software. Inspirado no FixAgent, pode incluir: Helper (para pesquisa de soluções online), RepoFocus (análise de código e dependências), Summarizer, Slicer (isola segmentos de código relevantes), Locator (identifica linhas de erro), Fixer (gera patches de código) e FixerPro (gera patches otimizados). As dependências incluiriam acesso a repositórios de código, ferramentas de análise estática/dinâmica e LLMs para raciocínio e geração de código.Cite: src-18
Modo de operação: Opera em um fluxo de trabalho hierárquico e adaptativo de três níveis, que pode ser iterativo. Começa com soluções mais simples e escala para análises mais profundas e invocações de ferramentas complexas se as tentativas iniciais falharem. Isso implica um loop de refinamento e execução condicional, onde a complexidade do bug determina o caminho de execução.Cite: src-18
Sincronização: A natureza sequencial de algumas etapas (e.g., Summarizer antes de Slicer) e a necessidade de invocar ferramentas externas (que são de E/S intensiva) sugerem uma combinação de execuções síncronas e assíncronas. O controle é provavelmente síncrono para garantir a ordem lógica do processo de depuração, mas as chamadas para ferramentas ou subagentes podem ser assíncronas para eficiência.Cite: src-3, src-4, src-5, src-6
Função do agente principal: O agente principal atua como o "Bug Assistant Orchestrator", responsável por receber relatórios de bugs, diagnosticar a complexidade do problema e orquestrar a equipe de subagentes para analisar o código, identificar a causa raiz e gerar uma correção.
Integração de ferramentas: Utiliza extensivamente ferramentas para pesquisa online de soluções (Helper), análise de repositórios de código, ferramentas de análise estática e dinâmica de código (que Slicer, Locator e Fixer podem invocar) e geração de patches de código.Cite: src-18
4.15. travel-concierge
Tipo de projeto: Multi-agent.Cite: src-14, src-26
Composição interna: É um sistema sofisticado que gerencia todo o ciclo de vida da viagem através de subagentes especializados. Os subagentes incluem: Main Agent (Orquestrador), Inspiration Agent, Planning Agent, Booking Agent, Pre-Trip Agent, In-Trip Agent e Post-Trip Agent. Pode ser integrado com LangDB para offload de lógica de ferramentas e observabilidade. A arquitetura usa sub_agents e um agente principal que orquestra o fluxo de trabalho e roteia as consultas do usuário. Pode ser implantado em Cloud Run ou Vertex AI Agent Engine. Utiliza APIs como Google Maps e Google Cloud Storage.Cite: src-14, src-26
Modo de operação: O sistema multi-agente sugere um modo de operação que pode envolver execução sequencial e paralela, dependendo da etapa do ciclo de vida da viagem. A orquestração pelo Main Agent direciona as consultas para os subagentes, indicando um fluxo controlado e adaptativo.Cite: src-14
Sincronização: As interações entre subagentes podem ser síncronas para etapas dependentes (e.g., planejar antes de reservar) ou assíncronas para operações independentes (e.g., buscar inspiração enquanto outra tarefa é processada). A natureza dos sistemas multi-agentes ADK suporta orquestração flexível incluindo fluxos sequenciais, paralelos e em loop, e o Runner do ADK opera assincronamente para garantir a eficiência.Cite: src-1, src-6, src-11
Função do agente principal: O "Main Agent" (Agente Principal) atua como orquestrador central, roteando as consultas dos usuários para os subagentes especializados apropriados para cada etapa do ciclo de vida da viagem. Ele coordena o fluxo de trabalho e as interações.Cite: src-14
Integração de ferramentas: O travel-concierge utiliza ferramentas para funcionalidades específicas de viagem, como integração com APIs de busca de voos, sistemas de reserva de hotéis, obtenção de dados meteorológicos em tempo real e recomendações de restaurantes. A integração com LangDB permite a abstração de ferramentas via Virtual MCPs para simplificar a integração com serviços externos.Cite: src-14, src-26
Fontes
src-1: https://google.github.io/adk-docs/docs/concepts/multi-agent-systems
src-2: https://google.github.io/adk-docs/docs/concepts/agent-types
src-3: https://google.github.io/adk-docs/docs/getting-started/
src-4: https://google.github.io/adk-docs/docs/concepts/runner
src-5: https://google.github.io/adk-docs/docs/reference/
src-6: https://google.github.io/adk-docs/docs/concepts/llm-agent-tooling
src-7: https://google.github.io/adk-docs/docs/concepts/agent-as-a-tool
src-8: https://google.github.io/adk-docs/docs/concepts/tools
src-9: https://google.github.io/adk-docs/docs/guides/tooling
src-10: https://google.github.io/adk-docs/docs/guides/multi-agent-orchestration
src-11: https://google.github.io/adk-docs/docs/concepts/workflow-agent
src-12: https://google.github.io/adk-docs/docs/concepts/model-context-protocol
src-13: https://google.github.io/adk-docs/docs/examples/
src-14: https://google.github.io/adk-docs/docs/concepts/travel-concierge-example
src-15: https://google.github.io/adk-docs/docs/concepts/agent-to-agent-protocol
src-16: https://google.github.io/adk-docs/docs/guides/virtual-mcp-tool
src-17: https://github.com/google/adk-samples/tree/main/python/agents
src-18: https://google.github.io/adk-docs/docs/concepts/fix-agent-example
src-19: https://google.github.io/adk-docs/docs/concepts/orchestration
src-20: https://google.github.io/adk-docs/docs/tutorials/brand-search-optimization-agent
src-21: https://google.github.io/adk-docs/docs/tutorials/brand-search-optimization-agent/#supported-tools
src-22: https://google.github.io/adk-docs/docs/tutorials/customer-service-agent
src-23: https://google.github.io/adk-docs/docs/tutorials/data-science-agent
src-24: https://google.github.io/adk-docs/docs/tutorials/gemini-fullstack
src-25: https://google.github.io/adk-docs/docs/tutorials/gemini-fullstack/#how-it-works
src-26: https://google.github.io/adk-docs/docs/tutorials/travel-concierge-agent